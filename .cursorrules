# Cursor Rules for AudioMeta Python

## Code Style and Comments

### Avoid Unnecessary Comments

Do NOT add comments for functions, classes, or modules that are self-explanatory. The function name, class name, and parameters should clearly indicate what they do.

#### ❌ Avoid these unnecessary comments:

```python
"""Test cases for artists metadata."""
class TestArtistsMetadata:
    """Test cases for artists metadata."""

def test_artists_metadata_mp3():
    """Test artists metadata for MP3 files."""

def test_forced_format_affects_delete_metadata_behavior():
    """Test that forced format affects delete_metadata behavior."""

def get_user_name():
    """This function returns the user's name."""
    return user.name

def calculate_total(price, tax):
    """This function calculates the total price."""
    return price + (price * tax)
```

#### ✅ Good - No comments needed:

```python
class TestArtistsMetadata:
    def test_artists_metadata_mp3(self, sample_mp3_file: Path, temp_audio_file: Path):
        # Test implementation here

    def test_forced_format_affects_delete_metadata_behavior(self):
        # Test implementation here

def get_user_name():
    return user.name

def calculate_total(price, tax):
    return price + (price * tax)
```

#### ✅ Only add comments when they provide value:

```python
def calculate_compound_interest(principal, rate, time):
    # Uses the formula: A = P(1 + r/n)^(nt) where n=12 for monthly compounding
    return principal * (1 + rate/12) ** (12 * time)

def process_audio_metadata(file_path):
    # Handles edge cases where ID3v2 tags may be corrupted
    # and falls back to ID3v1 if necessary
    try:
        return extract_id3v2_metadata(file_path)
    except CorruptedTagError:
        return extract_id3v1_metadata(file_path)
```

### When to Add Comments

Only add function, class, or module comments when:

1. The function/class implements complex business logic that isn't obvious
2. There are important edge cases or assumptions to document
3. The function/class has non-obvious side effects
4. The function/class uses algorithms or formulas that need explanation
5. There are performance considerations or limitations to note

### When NOT to Add Comments

Do NOT add comments for:

- Simple getter/setter functions
- Functions with descriptive names that clearly indicate their purpose
- Standard CRUD operations
- Functions that are self-documenting through their implementation
- Test functions with obvious names like `test_artists_metadata_mp3`
- Class docstrings that just repeat the class name
- Module docstrings that just describe what the module contains

## Python Style

### Type Hints

- Use `list`, `dict`, `tuple`, `|` instead of `List`, `Dict`, `Tuple`, `Union`
- Only add type hints when necessary for clarity

### Commit Messages

- Must be concise and descriptive
- Focus on what changed, not how
- Use conventional commit prefixes:
  - `feat:` for new features
  - `fix:` for bug fixes
  - `refactor:` for code refactoring
  - `chore:` for maintenance tasks
  - `chore(test):` for test-related changes (reorganization, new tests, etc.)
  - `docs:` for documentation changes
  - `style:` for formatting changes
  - `perf:` for performance improvements

#### Test-Related Commit Prefixes

Use `fix(test):` for:

- Fixing a bug in a test

Use `test:` for:

- General test update/fix

Use `chore:` for:

- Non-functional maintenance

Use `chore(test):` for:

- Maintenance related to tests (rare)
- Test reorganization or restructuring
- Standardizing test patterns (e.g., using script helpers consistently)
- Adding new test files or test utilities
- Updating test fixtures or test data
- Test maintenance and cleanup

## Test Organization

### Test Naming

- Test function names should be descriptive enough that comments are unnecessary
- Use `test_` prefix followed by what is being tested
- Include the format being tested when relevant (e.g., `test_artists_metadata_mp3`)

### Test Structure

- Group related tests in classes
- Use descriptive class names that don't need docstrings
- Focus on testing behavior, not implementation details

### Test File Management and Data Setup

**All audio file data access and writing operations must use `TempFileWithMetadata` methods.** This ensures code clarity, maintainability, and proper separation of concerns.

#### General Guidelines

- Use `TempFileWithMetadata` for creating temporary test files instead of `shutil.copy2`
- Always use context managers for temporary files
- Access file path via `test_file.path` property

#### ❌ Avoid using shutil for test files:

```python
def test_wav_sync_multiple_values(self, sample_wav_file: Path, temp_audio_file: Path):
    test_file = temp_audio_file.with_suffix('.wav')
    shutil.copy2(sample_wav_file, test_file)  # Don't do this
```

#### ✅ CORRECT - Use TempFileWithMetadata:

```python
def test_wav_sync_multiple_values(self, sample_wav_file: Path, temp_audio_file: Path):
    with TempFileWithMetadata({"title": "Initial Title"}, "wav") as test_file:
        # Set up metadata
        update_file_metadata(test_file.path, metadata)

        # Verify results
        result = get_merged_unified_metadata(test_file.path)
        assert result.get(UnifiedMetadataKey.TITLE) == "Expected Title"
```

#### ❌ WRONG - Don't use subprocess or external tools directly:

```python
def test_metadata_writing(self):
    with TempFileWithMetadata({}, "mp3") as test_file:
        # ❌ NEVER use subprocess or external tools directly in tests
        import subprocess
        subprocess.run([
            "mid3v2",
            "--song=Test Title",
            "--artist=Test Artist",
            str(test_file.path)
        ], check=True)

        # Test reading...
```

#### ✅ CORRECT - Use TempFileWithMetadata methods for all audio operations:

```python
def test_metadata_writing(self):
    with TempFileWithMetadata({}, "mp3") as test_file:
        # ✅ Use TempFileWithMetadata methods for all audio file operations
        test_file.set_id3v2_title("Test Title")
        test_file.set_id3v2_artist("Test Artist")

        # Test reading...
```

#### Why Use TempFileWithMetadata Methods

- **Code Clarity**: All audio file operations are centralized in one place
- **Maintainability**: Changes to audio file handling only need to be made in one location
- **Consistency**: All tests use the same interface for audio file operations
- **Reliability**: No dependency on external tools being available or configured correctly

#### Available TempFileWithMetadata Methods for Audio Operations

- **ID3v2**: `set_id3v2_title()`, `set_id3v2_artist()`, `set_id3v2_album()`, `set_id3v2_lyrics()`, etc.
- **ID3v1**: `set_id3v1_title()`, `set_id3v1_artist()`, `set_id3v1_album()`, etc.
- **Vorbis**: `set_vorbis_title()`, `set_vorbis_artist()`, `set_vorbis_album()`, etc.
- **RIFF**: `set_riff_title()`, `set_riff_artist()`, `set_riff_album()`, etc.
- **Max metadata**: `set_id3v2_max_metadata()`, `set_id3v1_max_metadata()`, etc.
- **Delete operations**: `delete_id3v2_lyrics()`, `delete_id3v2_title()`, etc.

#### ✅ Good test file usage:

```python
def test_wav_sync_multiple_values(self, sample_wav_file: Path, temp_audio_file: Path):
    with TempFileWithMetadata({"title": "Initial Title"}, "wav") as test_file:
        # Set up metadata
        update_file_metadata(test_file.path, metadata)

        # Verify results
        result = get_merged_unified_metadata(test_file.path)
        assert result.get(UnifiedMetadataKey.TITLE) == "Expected Title"
```

### Test Isolation and Avoiding Circular Dependencies

#### All Tests Must Use External Tools for Initial Data Setup

For tests that verify **reading, writing, or deleting functionality**, NEVER use the library's own `update_file_metadata()` function to set up initial test data. This ensures proper test isolation and prevents testing the library's own writing logic when testing other functionality.

#### ❌ WRONG - Poor test isolation:

```python
def test_id3v1_genre_reading(self):
    with TempFileWithMetadata({"title": "Test Song"}, "mp3") as test_file:
        # ❌ Using our own library to set metadata - poor test isolation
        update_file_metadata(test_file.path, {
            UnifiedMetadataKey.GENRES_NAMES: "Rock"
        }, metadata_format=MetadataFormat.ID3V1)

        # Testing reading - but we used our own writing logic!
        metadata = get_merged_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRES_NAMES) == ["Rock"]

def test_delete_lyrics_id3v2(self):
    with TempFileWithMetadata({}, "mp3") as test_file:
        # ❌ Using our own library to set initial data - poor test isolation
        update_file_metadata(test_file.path, {UnifiedMetadataKey.LYRICS: "Test lyrics"})

        # Testing deletion - but we used our own writing logic to set up!
        update_file_metadata(test_file.path, {UnifiedMetadataKey.LYRICS: None})
        assert get_specific_metadata(test_file.path, UnifiedMetadataKey.LYRICS) is None
```

#### ✅ CORRECT - Use external tools for proper test isolation:

```python
def test_id3v1_genre_reading(self):
    with TempFileWithMetadata({"title": "Test Song"}, "mp3") as test_file:
        # ✅ Use external tool to set metadata - proper test isolation
        test_file.set_id3v1_max_metadata()

        # Now test reading with external verification
        metadata = get_merged_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRES_NAMES) == ["Blues"]

def test_delete_lyrics_id3v2(self):
    with TempFileWithMetadata({}, "mp3") as test_file:
        # ✅ Use external tool to set initial data - proper test isolation
        test_file.set_id3v2_lyrics("Test lyrics")

        # Test deletion using our library
        update_file_metadata(test_file.path, {UnifiedMetadataKey.LYRICS: None})
        assert get_specific_metadata(test_file.path, UnifiedMetadataKey.LYRICS) is None
```

#### ✅ ALTERNATIVE - Use TempFileWithMetadata with specific format:

```python
def test_id3v1_genre_reading(self):
    # ✅ TempFileWithMetadata uses external tools internally
    with TempFileWithMetadata({"genre": "Rock"}, "id3v1") as test_file:
        metadata = get_merged_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRES_NAMES) == ["Rock"]
```

#### Available TempFileWithMetadata Methods

- **Max metadata methods**: `set_id3v1_max_metadata()`, `set_id3v2_max_metadata()`, `set_vorbis_max_metadata()`, `set_riff_max_metadata()`
- **Specific field methods**: `set_id3v2_lyrics()`, `set_id3v2_title()`, `set_id3v2_artist()`, `set_id3v2_album()`, etc.
- **Delete methods**: `delete_id3v2_lyrics()`, `delete_id3v2_title()`, `delete_id3v2_artist()`, etc.
- **TempFileWithMetadata**: Uses external tools internally for proper test isolation

#### When to Use Each Approach

- **Reading tests**: Use `TempFileWithMetadata` methods for initial data setup
- **Writing tests**: Use `TempFileWithMetadata` methods for initial data setup, then test `update_file_metadata()` functionality
- **Deleting tests**: Use `TempFileWithMetadata` methods for initial data setup, then test deletion using library API (`update_file_metadata()` with `None` values)
- **Integration tests**: Use `TempFileWithMetadata` methods consistently
- **Unit tests**: Use mocks and direct object instantiation

#### Test Principle: Only Test the API Function Being Tested

**The rule**: In any test, only use the API function that you're actually testing. Everything else should use helper methods.

**✅ CORRECT - Deletion tests:**

```python
def test_delete_comment_riff(self):
    with TempFileWithMetadata({}, "wav") as test_file:
        # ✅ Use helper method for setup - not testing setup functionality
        test_file.set_riff_comment("Test comment")
        assert get_specific_metadata(test_file.path, UnifiedMetadataKey.COMMENT) == "Test comment"

        # ✅ Test deletion using library API - this is what we're testing
        update_file_metadata(test_file.path, {UnifiedMetadataKey.COMMENT: None}, metadata_format=MetadataFormat.RIFF)
        assert get_specific_metadata(test_file.path, UnifiedMetadataKey.COMMENT) is None
```

**✅ CORRECT - Reading tests:**

```python
def test_read_comment_riff(self):
    with TempFileWithMetadata({}, "wav") as test_file:
        # ✅ Use helper method for setup - not testing setup functionality
        test_file.set_riff_comment("Test comment")

        # ✅ Test reading using library API - this is what we're testing
        comment = get_specific_metadata(test_file.path, UnifiedMetadataKey.COMMENT)
        assert comment == "Test comment"
```

**✅ CORRECT - Writing tests:**

```python
def test_write_comment_riff(self):
    with TempFileWithMetadata({}, "wav") as test_file:
        # ✅ Test writing using library API - this is what we're testing
        update_file_metadata(test_file.path, {UnifiedMetadataKey.COMMENT: "Test comment"}, metadata_format=MetadataFormat.RIFF)

        # ✅ Use helper method for verification - not testing reading functionality
        comment = get_specific_metadata(test_file.path, UnifiedMetadataKey.COMMENT)
        assert comment == "Test comment"
```

#### ❌ WRONG - Don't mix API functions in tests:

```python
def test_delete_comment_riff(self):
    with TempFileWithMetadata({}, "wav") as test_file:
        # ❌ Using library API for setup when testing deletion
        update_file_metadata(test_file.path, {UnifiedMetadataKey.COMMENT: "Test comment"}, metadata_format=MetadataFormat.RIFF)

        # ✅ This is correct - testing deletion
        update_file_metadata(test_file.path, {UnifiedMetadataKey.COMMENT: None}, metadata_format=MetadataFormat.RIFF)
        assert get_specific_metadata(test_file.path, UnifiedMetadataKey.COMMENT) is None
```

### Individual Metadata Reading Tests

#### Use get_specific_metadata for Single Metadata Field Tests

When testing reading of a **single metadata field**, use `get_specific_metadata()` instead of `get_merged_unified_metadata()` for better performance and clarity.

#### ❌ WRONG - Inefficient for single field:

```python
def test_title_reading(self, test_file):
    metadata = get_merged_unified_metadata(test_file.path)
    title = metadata.get(UnifiedMetadataKey.TITLE)
    assert title == "Expected Title"
```

#### ✅ CORRECT - Use get_specific_metadata:

```python
def test_title_reading(self, test_file):
    title = get_specific_metadata(test_file.path, UnifiedMetadataKey.TITLE)
    assert title == "Expected Title"
```

#### When to Use Each Function

- **`get_specific_metadata()`**: When testing a single metadata field
- **`get_merged_unified_metadata()`**: When testing multiple metadata fields or full metadata workflows

## File Organization

### Module Structure

- Keep related functionality together
- Use clear, descriptive file names
- Avoid unnecessary module docstrings that just describe the file contents

### Import Organization

- Group imports logically
- Use absolute imports when possible
- Keep imports clean and minimal
