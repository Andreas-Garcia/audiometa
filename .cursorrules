# Cursor Rules for AudioMeta Python

## Code Style and Comments

### Avoid Unnecessary Comments

Do NOT add comments for functions, classes, or modules that are self-explanatory. The function name, class name, and parameters should clearly indicate what they do.

#### ❌ Avoid these unnecessary comments:

```python
"""Test cases for artists metadata."""
class TestArtistsMetadata:
    """Test cases for artists metadata."""

def test_artists_metadata_mp3():
    """Test artists metadata for MP3 files."""

def test_forced_format_affects_delete_metadata_behavior():
    """Test that forced format affects delete_metadata behavior."""

def get_user_name():
    """This function returns the user's name."""
    return user.name

def calculate_total(price, tax):
    """This function calculates the total price."""
    return price + (price * tax)
```

#### ✅ Good - No comments needed:

```python
class TestArtistsMetadata:
    def test_artists_metadata_mp3(self, sample_mp3_file: Path, temp_audio_file: Path):
        # Test implementation here

    def test_forced_format_affects_delete_metadata_behavior(self):
        # Test implementation here

def get_user_name():
    return user.name

def calculate_total(price, tax):
    return price + (price * tax)
```

#### ✅ Only add comments when they provide value:

```python
def calculate_compound_interest(principal, rate, time):
    # Uses the formula: A = P(1 + r/n)^(nt) where n=12 for monthly compounding
    return principal * (1 + rate/12) ** (12 * time)

def process_audio_metadata(file_path):
    # Handles edge cases where ID3v2 tags may be corrupted
    # and falls back to ID3v1 if necessary
    try:
        return extract_id3v2_metadata(file_path)
    except CorruptedTagError:
        return extract_id3v1_metadata(file_path)
```

### When to Add Comments

Only add function, class, or module comments when:

1. The function/class implements complex business logic that isn't obvious
2. There are important edge cases or assumptions to document
3. The function/class has non-obvious side effects
4. The function/class uses algorithms or formulas that need explanation
5. There are performance considerations or limitations to note

### When NOT to Add Comments

Do NOT add comments for:

- Simple getter/setter functions
- Functions with descriptive names that clearly indicate their purpose
- Standard CRUD operations
- Functions that are self-documenting through their implementation
- Test functions with obvious names like `test_artists_metadata_mp3`
- Class docstrings that just repeat the class name
- Module docstrings that just describe what the module contains

## Python Style

### Type Hints

- Use `list`, `dict`, `tuple`, `|` instead of `List`, `Dict`, `Tuple`, `Union`
- Only add type hints when necessary for clarity

### Commit Messages

- Must be concise and descriptive
- Focus on what changed, not how
- Use conventional commit prefixes:
  - `feat:` for new features
  - `fix:` for bug fixes
  - `refactor:` for code refactoring
  - `chore:` for maintenance tasks
  - `chore(test):` for test-related changes (reorganization, new tests, etc.)
  - `docs:` for documentation changes
  - `style:` for formatting changes
  - `perf:` for performance improvements

#### Test-Related Commit Prefixes

Use `fix(test):` for:

- Fixing a bug in a test

Use `test:` for:

- General test update/fix

Use `chore:` for:

- Non-functional maintenance

Use `chore(test):` for:

- Maintenance related to tests (rare)
- Test reorganization or restructuring
- Standardizing test patterns (e.g., using script helpers consistently)
- Adding new test files or test utilities
- Updating test fixtures or test data
- Test maintenance and cleanup

## Test Organization

### Test Naming

- Test function names should be descriptive enough that comments are unnecessary
- Use `test_` prefix followed by what is being tested
- Include the format being tested when relevant (e.g., `test_artists_metadata_mp3`)

### Test Structure

- Group related tests in classes
- Use descriptive class names that don't need docstrings
- Focus on testing behavior, not implementation details

### Test File Management

- Use `TempFileWithMetadata` for creating temporary test files instead of `shutil.copy2`
- Always use context managers for temporary files
- Access file path via `test_file.path` property

#### ✅ Good test file usage:

```python
def test_wav_sync_multiple_values(self, sample_wav_file: Path, temp_audio_file: Path):
    with TempFileWithMetadata({"title": "Initial Title"}, "wav") as test_file:
        # Set up metadata
        update_file_metadata(test_file.path, metadata)

        # Verify results
        result = get_merged_unified_metadata(test_file.path)
        assert result.get(UnifiedMetadataKey.TITLE) == "Expected Title"
```

#### ❌ Avoid using shutil for test files:

```python
def test_wav_sync_multiple_values(self, sample_wav_file: Path, temp_audio_file: Path):
    test_file = temp_audio_file.with_suffix('.wav')
    shutil.copy2(sample_wav_file, test_file)  # Don't do this
```

### Test Isolation and Avoiding Circular Dependencies

#### Reading Tests Must Use External Tools

For tests that verify **reading functionality**, NEVER use the library's own `update_file_metadata()` function. This creates circular dependencies where writing logic could mask reading bugs.

#### ❌ WRONG - Creates circular dependency:

```python
def test_id3v1_genre_reading(self):
    with TempFileWithMetadata({"title": "Test Song"}, "mp3") as test_file:
        # ❌ Using our own library to set metadata
        update_file_metadata(test_file.path, {
            UnifiedMetadataKey.GENRE_NAME: "Rock"
        }, metadata_format=MetadataFormat.ID3V1)

        # Testing reading - but we used our own writing logic!
        metadata = get_merged_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRE_NAME) == ["Rock"]
```

#### ✅ CORRECT - Use external tools:

```python
def test_id3v1_genre_reading(self):
    with TempFileWithMetadata({"title": "Test Song"}, "mp3") as test_file:
        # ✅ Use external tool to set metadata
        script_helper = ScriptHelper()
        script_helper.set_id3v1_max_metadata(test_file.path)

        # Now test reading with external verification
        metadata = get_merged_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRE_NAME) == ["Blues"]
```

#### ✅ ALTERNATIVE - Use TempFileWithMetadata with specific format:

```python
def test_id3v1_genre_reading(self):
    # ✅ TempFileWithMetadata uses external tools internally
    with TempFileWithMetadata({"genre": "Rock"}, "id3v1") as test_file:
        metadata = get_merged_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRE_NAME) == ["Rock"]
```

#### ✅ ALTERNATIVE - Use subprocess with external tools:

```python
def test_riff_genre_reading(self):
    with TempFileWithMetadata({"title": "Test Song"}, "wav") as test_file:
        # ✅ Use external tool directly
        subprocess.run([
            "exiftool", "-overwrite_original",
            "-Genre=Rock; Alternative; Indie",
            str(test_file.path)
        ], check=True)

        metadata = get_merged_unified_metadata(test_file.path)
        assert metadata.get(UnifiedMetadataKey.GENRE_NAME) == ["Rock"]
```

#### Available External Tools

- **ScriptHelper class**: `set_id3v1_max_metadata()`, `set_id3v2_max_metadata()`, `set_vorbis_max_metadata()`, `set_riff_max_metadata()`
- **External tools**: `id3v2`, `mid3v2`, `metaflac`, `bwfmetaedit`, `exiftool`, `ffmpeg`
- **TempFileWithMetadata**: Uses external tools internally for specific formats

#### When to Use Each Approach

- **Reading tests**: Always use external tools or `TempFileWithMetadata` with specific format
- **Writing tests**: Can use `update_file_metadata()` (testing writing functionality)
- **Integration tests**: Mix both approaches as appropriate
- **Unit tests**: Use mocks and direct object instantiation

### Individual Metadata Reading Tests

#### Use get_specific_metadata for Single Metadata Field Tests

When testing reading of a **single metadata field**, use `get_specific_metadata()` instead of `get_merged_unified_metadata()` for better performance and clarity.

#### ❌ WRONG - Inefficient for single field:

```python
def test_title_reading(self, test_file):
    metadata = get_merged_unified_metadata(test_file.path)
    title = metadata.get(UnifiedMetadataKey.TITLE)
    assert title == "Expected Title"
```

#### ✅ CORRECT - Use get_specific_metadata:

```python
def test_title_reading(self, test_file):
    title = get_specific_metadata(test_file.path, UnifiedMetadataKey.TITLE)
    assert title == "Expected Title"
```

#### When to Use Each Function

- **`get_specific_metadata()`**: When testing a single metadata field
- **`get_merged_unified_metadata()`**: When testing multiple metadata fields or full metadata workflows

## File Organization

### Module Structure

- Keep related functionality together
- Use clear, descriptive file names
- Avoid unnecessary module docstrings that just describe the file contents

### Import Organization

- Group imports logically
- Use absolute imports when possible
- Keep imports clean and minimal
